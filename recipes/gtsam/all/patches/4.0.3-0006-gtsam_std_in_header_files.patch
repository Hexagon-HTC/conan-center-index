diff --git a/gtsam/3rdparty/Eigen/bench/BenchSparseUtil.h b/gtsam/3rdparty/Eigen/bench/BenchSparseUtil.h
index 13981f6b7..75ad1df3c 100644
--- a/gtsam/3rdparty/Eigen/bench/BenchSparseUtil.h
+++ b/gtsam/3rdparty/Eigen/bench/BenchSparseUtil.h
@@ -3,7 +3,6 @@
 #include <bench/BenchTimer.h>
 #include <set>
 
-using namespace std;
 using namespace Eigen;
 using namespace Eigen;
 
diff --git a/gtsam/3rdparty/Eigen/bench/BenchUtil.h b/gtsam/3rdparty/Eigen/bench/BenchUtil.h
index 8883a1380..5a65b91c1 100644
--- a/gtsam/3rdparty/Eigen/bench/BenchUtil.h
+++ b/gtsam/3rdparty/Eigen/bench/BenchUtil.h
@@ -5,7 +5,6 @@
 #include <Eigen/Core>
 #include "BenchTimer.h"
 
-using namespace std;
 using namespace Eigen;
 
 #include <boost/preprocessor/repetition/enum_params.hpp>
@@ -40,7 +39,7 @@ template<typename MatrixType> void initMatrix_identity(MatrixType& mat)
   : : [aux] "m" (aux)); \
 }
 #else
-#define DISABLE_SSE_EXCEPTIONS()  
+#define DISABLE_SSE_EXCEPTIONS()
 #endif
 
 #ifdef BENCH_GMM
diff --git a/gtsam/3rdparty/Eigen/bench/spbench/spbenchsolver.h b/gtsam/3rdparty/Eigen/bench/spbench/spbenchsolver.h
index 19c719c04..e1ccddc59 100644
--- a/gtsam/3rdparty/Eigen/bench/spbench/spbenchsolver.h
+++ b/gtsam/3rdparty/Eigen/bench/spbench/spbenchsolver.h
@@ -73,18 +73,17 @@
 #define EIGEN_CG_PRECOND  180
 
 using namespace Eigen;
-using namespace std; 
 
 
 // Global variables for input parameters
 int MaximumIters; // Maximum number of iterations
 double RelErr; // Relative error of the computed solution
-double best_time_val; // Current best time overall solvers 
-int best_time_id; //  id of the best solver for the current system 
+double best_time_val; // Current best time overall solvers
+int best_time_id; //  id of the best solver for the current system
 
 template<typename T> inline typename NumTraits<T>::Real test_precision() { return NumTraits<T>::dummy_precision(); }
-template<> inline float test_precision<float>() { return 1e-3f; }                                                             
-template<> inline double test_precision<double>() { return 1e-6; }                                                            
+template<> inline float test_precision<float>() { return 1e-3f; }
+template<> inline double test_precision<double>() { return 1e-6; }
 template<> inline float test_precision<std::complex<float> >() { return test_precision<float>(); }
 template<> inline double test_precision<std::complex<double> >() { return test_precision<double>(); }
 
@@ -92,137 +91,137 @@ void printStatheader(std::ofstream& out)
 {
   // Print XML header
   // NOTE It would have been much easier to write these XML documents using external libraries like tinyXML or Xerces-C++.
-  
+
   out << "<?xml version='1.0' encoding='UTF-8'?> \n";
-  out << "<?xml-stylesheet type='text/xsl' href='#stylesheet' ?> \n"; 
+  out << "<?xml-stylesheet type='text/xsl' href='#stylesheet' ?> \n";
   out << "<!DOCTYPE BENCH  [\n<!ATTLIST xsl:stylesheet\n id\t ID  #REQUIRED>\n]>";
-  out << "\n\n<!-- Generated by the Eigen library -->\n"; 
-  
-  out << "\n<BENCH> \n" ; //root XML element 
+  out << "\n\n<!-- Generated by the Eigen library -->\n";
+
+  out << "\n<BENCH> \n" ; //root XML element
   // Print the xsl style section
-  printBenchStyle(out); 
-  // List all available solvers 
+  printBenchStyle(out);
+  // List all available solvers
   out << " <AVAILSOLVER> \n";
 #ifdef EIGEN_UMFPACK_SUPPORT
-  out <<"  <SOLVER ID='" << EIGEN_UMFPACK << "'>\n"; 
+  out <<"  <SOLVER ID='" << EIGEN_UMFPACK << "'>\n";
   out << "   <TYPE> LU </TYPE> \n";
-  out << "   <PACKAGE> UMFPACK </PACKAGE> \n"; 
-  out << "  </SOLVER> \n"; 
+  out << "   <PACKAGE> UMFPACK </PACKAGE> \n";
+  out << "  </SOLVER> \n";
 #endif
 #ifdef EIGEN_SUPERLU_SUPPORT
-  out <<"  <SOLVER ID='" << EIGEN_SUPERLU << "'>\n"; 
+  out <<"  <SOLVER ID='" << EIGEN_SUPERLU << "'>\n";
   out << "   <TYPE> LU </TYPE> \n";
-  out << "   <PACKAGE> SUPERLU </PACKAGE> \n"; 
-  out << "  </SOLVER> \n"; 
+  out << "   <PACKAGE> SUPERLU </PACKAGE> \n";
+  out << "  </SOLVER> \n";
 #endif
 #ifdef EIGEN_CHOLMOD_SUPPORT
-  out <<"  <SOLVER ID='" << EIGEN_CHOLMOD_SIMPLICIAL_LLT << "'>\n"; 
+  out <<"  <SOLVER ID='" << EIGEN_CHOLMOD_SIMPLICIAL_LLT << "'>\n";
   out << "   <TYPE> LLT SP</TYPE> \n";
   out << "   <PACKAGE> CHOLMOD </PACKAGE> \n";
-  out << "  </SOLVER> \n"; 
-  
-  out <<"  <SOLVER ID='" << EIGEN_CHOLMOD_SUPERNODAL_LLT << "'>\n"; 
+  out << "  </SOLVER> \n";
+
+  out <<"  <SOLVER ID='" << EIGEN_CHOLMOD_SUPERNODAL_LLT << "'>\n";
   out << "   <TYPE> LLT</TYPE> \n";
   out << "   <PACKAGE> CHOLMOD </PACKAGE> \n";
   out << "  </SOLVER> \n";
-  
-  out <<"  <SOLVER ID='" << EIGEN_CHOLMOD_LDLT << "'>\n"; 
+
+  out <<"  <SOLVER ID='" << EIGEN_CHOLMOD_LDLT << "'>\n";
   out << "   <TYPE> LDLT </TYPE> \n";
-  out << "   <PACKAGE> CHOLMOD </PACKAGE> \n";  
-  out << "  </SOLVER> \n"; 
+  out << "   <PACKAGE> CHOLMOD </PACKAGE> \n";
+  out << "  </SOLVER> \n";
 #endif
 #ifdef EIGEN_PARDISO_SUPPORT
-  out <<"  <SOLVER ID='" << EIGEN_PARDISO << "'>\n"; 
+  out <<"  <SOLVER ID='" << EIGEN_PARDISO << "'>\n";
   out << "   <TYPE> LU </TYPE> \n";
-  out << "   <PACKAGE> PARDISO </PACKAGE> \n"; 
-  out << "  </SOLVER> \n"; 
-  
-  out <<"  <SOLVER ID='" << EIGEN_PARDISO_LLT << "'>\n"; 
+  out << "   <PACKAGE> PARDISO </PACKAGE> \n";
+  out << "  </SOLVER> \n";
+
+  out <<"  <SOLVER ID='" << EIGEN_PARDISO_LLT << "'>\n";
   out << "   <TYPE> LLT </TYPE> \n";
-  out << "   <PACKAGE> PARDISO </PACKAGE> \n"; 
-  out << "  </SOLVER> \n"; 
-  
-  out <<"  <SOLVER ID='" << EIGEN_PARDISO_LDLT << "'>\n"; 
+  out << "   <PACKAGE> PARDISO </PACKAGE> \n";
+  out << "  </SOLVER> \n";
+
+  out <<"  <SOLVER ID='" << EIGEN_PARDISO_LDLT << "'>\n";
   out << "   <TYPE> LDLT </TYPE> \n";
-  out << "   <PACKAGE> PARDISO </PACKAGE> \n"; 
-  out << "  </SOLVER> \n"; 
+  out << "   <PACKAGE> PARDISO </PACKAGE> \n";
+  out << "  </SOLVER> \n";
 #endif
 #ifdef EIGEN_PASTIX_SUPPORT
-  out <<"  <SOLVER ID='" << EIGEN_PASTIX << "'>\n"; 
+  out <<"  <SOLVER ID='" << EIGEN_PASTIX << "'>\n";
   out << "   <TYPE> LU </TYPE> \n";
-  out << "   <PACKAGE> PASTIX </PACKAGE> \n"; 
-  out << "  </SOLVER> \n"; 
-  
-  out <<"  <SOLVER ID='" << EIGEN_PASTIX_LLT << "'>\n"; 
+  out << "   <PACKAGE> PASTIX </PACKAGE> \n";
+  out << "  </SOLVER> \n";
+
+  out <<"  <SOLVER ID='" << EIGEN_PASTIX_LLT << "'>\n";
   out << "   <TYPE> LLT </TYPE> \n";
-  out << "   <PACKAGE> PASTIX </PACKAGE> \n"; 
-  out << "  </SOLVER> \n"; 
-  
-  out <<"  <SOLVER ID='" << EIGEN_PASTIX_LDLT << "'>\n"; 
+  out << "   <PACKAGE> PASTIX </PACKAGE> \n";
+  out << "  </SOLVER> \n";
+
+  out <<"  <SOLVER ID='" << EIGEN_PASTIX_LDLT << "'>\n";
   out << "   <TYPE> LDLT </TYPE> \n";
-  out << "   <PACKAGE> PASTIX </PACKAGE> \n"; 
-  out << "  </SOLVER> \n"; 
+  out << "   <PACKAGE> PASTIX </PACKAGE> \n";
+  out << "  </SOLVER> \n";
 #endif
-  
-  out <<"  <SOLVER ID='" << EIGEN_BICGSTAB << "'>\n"; 
+
+  out <<"  <SOLVER ID='" << EIGEN_BICGSTAB << "'>\n";
   out << "   <TYPE> BICGSTAB </TYPE> \n";
-  out << "   <PACKAGE> EIGEN </PACKAGE> \n"; 
-  out << "  </SOLVER> \n"; 
-  
-  out <<"  <SOLVER ID='" << EIGEN_BICGSTAB_ILUT << "'>\n"; 
+  out << "   <PACKAGE> EIGEN </PACKAGE> \n";
+  out << "  </SOLVER> \n";
+
+  out <<"  <SOLVER ID='" << EIGEN_BICGSTAB_ILUT << "'>\n";
   out << "   <TYPE> BICGSTAB_ILUT </TYPE> \n";
-  out << "   <PACKAGE> EIGEN </PACKAGE> \n"; 
-  out << "  </SOLVER> \n"; 
-  
-  out <<"  <SOLVER ID='" << EIGEN_GMRES_ILUT << "'>\n"; 
+  out << "   <PACKAGE> EIGEN </PACKAGE> \n";
+  out << "  </SOLVER> \n";
+
+  out <<"  <SOLVER ID='" << EIGEN_GMRES_ILUT << "'>\n";
   out << "   <TYPE> GMRES_ILUT </TYPE> \n";
-  out << "   <PACKAGE> EIGEN </PACKAGE> \n"; 
-  out << "  </SOLVER> \n"; 
-  
-  out <<"  <SOLVER ID='" << EIGEN_SIMPLICIAL_LDLT << "'>\n"; 
+  out << "   <PACKAGE> EIGEN </PACKAGE> \n";
+  out << "  </SOLVER> \n";
+
+  out <<"  <SOLVER ID='" << EIGEN_SIMPLICIAL_LDLT << "'>\n";
   out << "   <TYPE> LDLT </TYPE> \n";
-  out << "   <PACKAGE> EIGEN </PACKAGE> \n"; 
-  out << "  </SOLVER> \n"; 
-  
-  out <<"  <SOLVER ID='" << EIGEN_SIMPLICIAL_LLT << "'>\n"; 
+  out << "   <PACKAGE> EIGEN </PACKAGE> \n";
+  out << "  </SOLVER> \n";
+
+  out <<"  <SOLVER ID='" << EIGEN_SIMPLICIAL_LLT << "'>\n";
   out << "   <TYPE> LLT </TYPE> \n";
-  out << "   <PACKAGE> EIGEN </PACKAGE> \n"; 
-  out << "  </SOLVER> \n"; 
-  
-  out <<"  <SOLVER ID='" << EIGEN_CG << "'>\n"; 
+  out << "   <PACKAGE> EIGEN </PACKAGE> \n";
+  out << "  </SOLVER> \n";
+
+  out <<"  <SOLVER ID='" << EIGEN_CG << "'>\n";
   out << "   <TYPE> CG </TYPE> \n";
-  out << "   <PACKAGE> EIGEN </PACKAGE> \n"; 
-  out << "  </SOLVER> \n"; 
-  
-  out <<"  <SOLVER ID='" << EIGEN_SPARSELU_COLAMD << "'>\n"; 
+  out << "   <PACKAGE> EIGEN </PACKAGE> \n";
+  out << "  </SOLVER> \n";
+
+  out <<"  <SOLVER ID='" << EIGEN_SPARSELU_COLAMD << "'>\n";
   out << "   <TYPE> LU_COLAMD </TYPE> \n";
-  out << "   <PACKAGE> EIGEN </PACKAGE> \n"; 
-  out << "  </SOLVER> \n"; 
-  
+  out << "   <PACKAGE> EIGEN </PACKAGE> \n";
+  out << "  </SOLVER> \n";
+
 #ifdef EIGEN_METIS_SUPPORT
-  out <<"  <SOLVER ID='" << EIGEN_SPARSELU_METIS << "'>\n"; 
+  out <<"  <SOLVER ID='" << EIGEN_SPARSELU_METIS << "'>\n";
   out << "   <TYPE> LU_METIS </TYPE> \n";
-  out << "   <PACKAGE> EIGEN </PACKAGE> \n"; 
-  out << "  </SOLVER> \n"; 
+  out << "   <PACKAGE> EIGEN </PACKAGE> \n";
+  out << "  </SOLVER> \n";
 #endif
-  out << " </AVAILSOLVER> \n"; 
-  
+  out << " </AVAILSOLVER> \n";
+
 }
 
 
 template<typename Solver, typename Scalar>
 void call_solver(Solver &solver, const int solver_id, const typename Solver::MatrixType& A, const Matrix<Scalar, Dynamic, 1>& b, const Matrix<Scalar, Dynamic, 1>& refX,std::ofstream& statbuf)
 {
-  
+
   double total_time;
   double compute_time;
-  double solve_time; 
+  double solve_time;
   double rel_error;
-  Matrix<Scalar, Dynamic, 1> x; 
-  BenchTimer timer; 
+  Matrix<Scalar, Dynamic, 1> x;
+  BenchTimer timer;
   timer.reset();
   timer.start();
-  solver.compute(A); 
+  solver.compute(A);
   if (solver.info() != Success)
   {
     std::cerr << "Solver failed ... \n";
@@ -230,13 +229,13 @@ void call_solver(Solver &solver, const int solver_id, const typename Solver::Mat
   }
   timer.stop();
   compute_time = timer.value();
-  statbuf << "    <TIME>\n"; 
+  statbuf << "    <TIME>\n";
   statbuf << "     <COMPUTE> " << timer.value() << "</COMPUTE>\n";
-  std::cout<< "COMPUTE TIME : " << timer.value() <<std::endl; 
-    
+  std::cout<< "COMPUTE TIME : " << timer.value() <<std::endl;
+
   timer.reset();
   timer.start();
-  x = solver.solve(b); 
+  x = solver.solve(b);
   if (solver.info() == NumericalIssue)
   {
     std::cerr << "Solver failed ... \n";
@@ -244,25 +243,25 @@ void call_solver(Solver &solver, const int solver_id, const typename Solver::Mat
   }
   timer.stop();
   solve_time = timer.value();
-  statbuf << "     <SOLVE> " << timer.value() << "</SOLVE>\n"; 
-  std::cout<< "SOLVE TIME : " << timer.value() <<std::endl; 
-  
+  statbuf << "     <SOLVE> " << timer.value() << "</SOLVE>\n";
+  std::cout<< "SOLVE TIME : " << timer.value() <<std::endl;
+
   total_time = solve_time + compute_time;
-  statbuf << "     <TOTAL> " << total_time << "</TOTAL>\n"; 
-  std::cout<< "TOTAL TIME : " << total_time <<std::endl; 
-  statbuf << "    </TIME>\n"; 
-  
+  statbuf << "     <TOTAL> " << total_time << "</TOTAL>\n";
+  std::cout<< "TOTAL TIME : " << total_time <<std::endl;
+  statbuf << "    </TIME>\n";
+
   // Verify the relative error
   if(refX.size() != 0)
     rel_error = (refX - x).norm()/refX.norm();
-  else 
+  else
   {
     // Compute the relative residual norm
-    Matrix<Scalar, Dynamic, 1> temp; 
-    temp = A * x; 
+    Matrix<Scalar, Dynamic, 1> temp;
+    temp = A * x;
     rel_error = (b-temp).norm()/b.norm();
   }
-  statbuf << "    <ERROR> " << rel_error << "</ERROR>\n"; 
+  statbuf << "    <ERROR> " << rel_error << "</ERROR>\n";
   std::cout<< "REL. ERROR : " << rel_error << "\n\n" ;
   if ( rel_error <= RelErr )
   {
@@ -279,7 +278,7 @@ template<typename Solver, typename Scalar>
 void call_directsolver(Solver& solver, const int solver_id, const typename Solver::MatrixType& A, const Matrix<Scalar, Dynamic, 1>& b, const Matrix<Scalar, Dynamic, 1>& refX, std::string& statFile)
 {
     std::ofstream statbuf(statFile.c_str(), std::ios::app);
-    statbuf << "   <SOLVER_STAT ID='" << solver_id <<"'>\n"; 
+    statbuf << "   <SOLVER_STAT ID='" << solver_id <<"'>\n";
     call_solver(solver, solver_id, A, b, refX,statbuf);
     statbuf << "   </SOLVER_STAT>\n";
     statbuf.close();
@@ -288,48 +287,48 @@ void call_directsolver(Solver& solver, const int solver_id, const typename Solve
 template<typename Solver, typename Scalar>
 void call_itersolver(Solver &solver, const int solver_id, const typename Solver::MatrixType& A, const Matrix<Scalar, Dynamic, 1>& b, const Matrix<Scalar, Dynamic, 1>& refX, std::string& statFile)
 {
-  solver.setTolerance(RelErr); 
+  solver.setTolerance(RelErr);
   solver.setMaxIterations(MaximumIters);
-  
+
   std::ofstream statbuf(statFile.c_str(), std::ios::app);
-  statbuf << " <SOLVER_STAT ID='" << solver_id <<"'>\n"; 
-  call_solver(solver, solver_id, A, b, refX,statbuf); 
+  statbuf << " <SOLVER_STAT ID='" << solver_id <<"'>\n";
+  call_solver(solver, solver_id, A, b, refX,statbuf);
   statbuf << "   <ITER> "<< solver.iterations() << "</ITER>\n";
   statbuf << " </SOLVER_STAT>\n";
-  std::cout << "ITERATIONS : " << solver.iterations() <<"\n\n\n"; 
-  
+  std::cout << "ITERATIONS : " << solver.iterations() <<"\n\n\n";
+
 }
 
 
 template <typename Scalar>
 void SelectSolvers(const SparseMatrix<Scalar>&A, unsigned int sym, Matrix<Scalar, Dynamic, 1>& b, const Matrix<Scalar, Dynamic, 1>& refX, std::string& statFile)
 {
-  typedef SparseMatrix<Scalar, ColMajor> SpMat; 
+  typedef SparseMatrix<Scalar, ColMajor> SpMat;
   // First, deal with Nonsymmetric and symmetric matrices
-  best_time_id = 0; 
+  best_time_id = 0;
   best_time_val = 0.0;
   //UMFPACK
   #ifdef EIGEN_UMFPACK_SUPPORT
   {
-    cout << "Solving with UMFPACK LU ... \n"; 
-    UmfPackLU<SpMat> solver; 
-    call_directsolver(solver, EIGEN_UMFPACK, A, b, refX,statFile); 
+    std::cout << "Solving with UMFPACK LU ... \n";
+    UmfPackLU<SpMat> solver;
+    call_directsolver(solver, EIGEN_UMFPACK, A, b, refX,statFile);
   }
   #endif
     //SuperLU
   #ifdef EIGEN_SUPERLU_SUPPORT
   {
-    cout << "\nSolving with SUPERLU ... \n"; 
+    std::cout << "\nSolving with SUPERLU ... \n";
     SuperLU<SpMat> solver;
-    call_directsolver(solver, EIGEN_SUPERLU, A, b, refX,statFile); 
+    call_directsolver(solver, EIGEN_SUPERLU, A, b, refX,statFile);
   }
   #endif
-    
+
    // PaStix LU
   #ifdef EIGEN_PASTIX_SUPPORT
   {
-    cout << "\nSolving with PASTIX LU ... \n"; 
-    PastixLU<SpMat> solver; 
+    std::cout << "\nSolving with PASTIX LU ... \n";
+    PastixLU<SpMat> solver;
     call_directsolver(solver, EIGEN_PASTIX, A, b, refX,statFile) ;
   }
   #endif
@@ -337,87 +336,87 @@ void SelectSolvers(const SparseMatrix<Scalar>&A, unsigned int sym, Matrix<Scalar
    //PARDISO LU
   #ifdef EIGEN_PARDISO_SUPPORT
   {
-    cout << "\nSolving with PARDISO LU ... \n"; 
-    PardisoLU<SpMat>  solver; 
+    std::cout << "\nSolving with PARDISO LU ... \n";
+    PardisoLU<SpMat>  solver;
     call_directsolver(solver, EIGEN_PARDISO, A, b, refX,statFile);
   }
   #endif
-  
+
   // Eigen SparseLU METIS
-  cout << "\n Solving with Sparse LU AND COLAMD ... \n";
+  std::cout << "\n Solving with Sparse LU AND COLAMD ... \n";
   SparseLU<SpMat, COLAMDOrdering<int> >   solver;
-  call_directsolver(solver, EIGEN_SPARSELU_COLAMD, A, b, refX, statFile); 
+  call_directsolver(solver, EIGEN_SPARSELU_COLAMD, A, b, refX, statFile);
   // Eigen SparseLU METIS
   #ifdef EIGEN_METIS_SUPPORT
   {
-    cout << "\n Solving with Sparse LU AND METIS ... \n";
+    std::cout << "\n Solving with Sparse LU AND METIS ... \n";
     SparseLU<SpMat, MetisOrdering<int> >   solver;
-    call_directsolver(solver, EIGEN_SPARSELU_METIS, A, b, refX, statFile); 
+    call_directsolver(solver, EIGEN_SPARSELU_METIS, A, b, refX, statFile);
   }
   #endif
-  
+
   //BiCGSTAB
   {
-    cout << "\nSolving with BiCGSTAB ... \n"; 
-    BiCGSTAB<SpMat> solver; 
+    std::cout << "\nSolving with BiCGSTAB ... \n";
+    BiCGSTAB<SpMat> solver;
     call_itersolver(solver, EIGEN_BICGSTAB, A, b, refX,statFile);
   }
   //BiCGSTAB+ILUT
   {
-    cout << "\nSolving with BiCGSTAB and ILUT ... \n"; 
-    BiCGSTAB<SpMat, IncompleteLUT<Scalar> > solver; 
-    call_itersolver(solver, EIGEN_BICGSTAB_ILUT, A, b, refX,statFile); 
+    std::cout << "\nSolving with BiCGSTAB and ILUT ... \n";
+    BiCGSTAB<SpMat, IncompleteLUT<Scalar> > solver;
+    call_itersolver(solver, EIGEN_BICGSTAB_ILUT, A, b, refX,statFile);
   }
-  
-   
+
+
   //GMRES
 //   {
-//     cout << "\nSolving with GMRES ... \n"; 
-//     GMRES<SpMat> solver; 
-//     call_itersolver(solver, EIGEN_GMRES, A, b, refX,statFile); 
+//     std::cout << "\nSolving with GMRES ... \n";
+//     GMRES<SpMat> solver;
+//     call_itersolver(solver, EIGEN_GMRES, A, b, refX,statFile);
 //   }
   //GMRES+ILUT
   {
-    cout << "\nSolving with GMRES and ILUT ... \n"; 
-    GMRES<SpMat, IncompleteLUT<Scalar> > solver; 
+    std::cout << "\nSolving with GMRES and ILUT ... \n";
+    GMRES<SpMat, IncompleteLUT<Scalar> > solver;
     call_itersolver(solver, EIGEN_GMRES_ILUT, A, b, refX,statFile);
   }
-  
+
   // Hermitian and not necessarily positive-definites
   if (sym != NonSymmetric)
   {
     // Internal Cholesky
     {
-      cout << "\nSolving with Simplicial LDLT ... \n"; 
+      std::cout << "\nSolving with Simplicial LDLT ... \n";
       SimplicialLDLT<SpMat, Lower> solver;
-      call_directsolver(solver, EIGEN_SIMPLICIAL_LDLT, A, b, refX,statFile); 
+      call_directsolver(solver, EIGEN_SIMPLICIAL_LDLT, A, b, refX,statFile);
     }
-    
+
     // CHOLMOD
     #ifdef EIGEN_CHOLMOD_SUPPORT
     {
-      cout << "\nSolving with CHOLMOD LDLT ... \n"; 
+      std::cout << "\nSolving with CHOLMOD LDLT ... \n";
       CholmodDecomposition<SpMat, Lower> solver;
       solver.setMode(CholmodLDLt);
        call_directsolver(solver,EIGEN_CHOLMOD_LDLT, A, b, refX,statFile);
     }
     #endif
-    
+
     //PASTIX LLT
     #ifdef EIGEN_PASTIX_SUPPORT
     {
-      cout << "\nSolving with PASTIX LDLT ... \n"; 
-      PastixLDLT<SpMat, Lower> solver; 
-      call_directsolver(solver,EIGEN_PASTIX_LDLT, A, b, refX,statFile); 
+      std::cout << "\nSolving with PASTIX LDLT ... \n";
+      PastixLDLT<SpMat, Lower> solver;
+      call_directsolver(solver,EIGEN_PASTIX_LDLT, A, b, refX,statFile);
     }
     #endif
-    
+
     //PARDISO LLT
     #ifdef EIGEN_PARDISO_SUPPORT
     {
-      cout << "\nSolving with PARDISO LDLT ... \n"; 
-      PardisoLDLT<SpMat, Lower> solver; 
-      call_directsolver(solver,EIGEN_PARDISO_LDLT, A, b, refX,statFile); 
+      std::cout << "\nSolving with PARDISO LDLT ... \n";
+      PardisoLDLT<SpMat, Lower> solver;
+      call_directsolver(solver,EIGEN_PARDISO_LDLT, A, b, refX,statFile);
     }
     #endif
   }
@@ -425,130 +424,130 @@ void SelectSolvers(const SparseMatrix<Scalar>&A, unsigned int sym, Matrix<Scalar
    // Now, symmetric POSITIVE DEFINITE matrices
   if (sym == SPD)
   {
-    
+
     //Internal Sparse Cholesky
     {
-      cout << "\nSolving with SIMPLICIAL LLT ... \n"; 
-      SimplicialLLT<SpMat, Lower> solver; 
-      call_directsolver(solver,EIGEN_SIMPLICIAL_LLT, A, b, refX,statFile); 
+      std::cout << "\nSolving with SIMPLICIAL LLT ... \n";
+      SimplicialLLT<SpMat, Lower> solver;
+      call_directsolver(solver,EIGEN_SIMPLICIAL_LLT, A, b, refX,statFile);
     }
-    
+
     // CHOLMOD
     #ifdef EIGEN_CHOLMOD_SUPPORT
     {
       // CholMOD SuperNodal LLT
-      cout << "\nSolving with CHOLMOD LLT (Supernodal)... \n"; 
+      std::cout << "\nSolving with CHOLMOD LLT (Supernodal)... \n";
       CholmodDecomposition<SpMat, Lower> solver;
       solver.setMode(CholmodSupernodalLLt);
        call_directsolver(solver,EIGEN_CHOLMOD_SUPERNODAL_LLT, A, b, refX,statFile);
       // CholMod Simplicial LLT
-      cout << "\nSolving with CHOLMOD LLT (Simplicial) ... \n"; 
+      std::cout << "\nSolving with CHOLMOD LLT (Simplicial) ... \n";
       solver.setMode(CholmodSimplicialLLt);
       call_directsolver(solver,EIGEN_CHOLMOD_SIMPLICIAL_LLT, A, b, refX,statFile);
     }
     #endif
-    
+
     //PASTIX LLT
     #ifdef EIGEN_PASTIX_SUPPORT
     {
-      cout << "\nSolving with PASTIX LLT ... \n"; 
-      PastixLLT<SpMat, Lower> solver; 
+      std::cout << "\nSolving with PASTIX LLT ... \n";
+      PastixLLT<SpMat, Lower> solver;
       call_directsolver(solver,EIGEN_PASTIX_LLT, A, b, refX,statFile);
     }
     #endif
-    
+
     //PARDISO LLT
     #ifdef EIGEN_PARDISO_SUPPORT
     {
-      cout << "\nSolving with PARDISO LLT ... \n"; 
-      PardisoLLT<SpMat, Lower> solver; 
-      call_directsolver(solver,EIGEN_PARDISO_LLT, A, b, refX,statFile); 
+      std::cout << "\nSolving with PARDISO LLT ... \n";
+      PardisoLLT<SpMat, Lower> solver;
+      call_directsolver(solver,EIGEN_PARDISO_LLT, A, b, refX,statFile);
     }
     #endif
-    
+
     // Internal CG
     {
-      cout << "\nSolving with CG ... \n"; 
-      ConjugateGradient<SpMat, Lower> solver; 
+      std::cout << "\nSolving with CG ... \n";
+      ConjugateGradient<SpMat, Lower> solver;
       call_itersolver(solver,EIGEN_CG, A, b, refX,statFile);
     }
     //CG+IdentityPreconditioner
 //     {
-//       cout << "\nSolving with CG and IdentityPreconditioner ... \n"; 
-//       ConjugateGradient<SpMat, Lower, IdentityPreconditioner> solver; 
+//       std::cout << "\nSolving with CG and IdentityPreconditioner ... \n";
+//       ConjugateGradient<SpMat, Lower, IdentityPreconditioner> solver;
 //       call_itersolver(solver,EIGEN_CG_PRECOND, A, b, refX,statFile);
 //     }
-  } // End SPD matrices 
+  } // End SPD matrices
 }
 
-/* Browse all the matrices available in the specified folder 
+/* Browse all the matrices available in the specified folder
  * and solve the associated linear system.
  * The results of each solve are printed in the standard output
  * and optionally in the provided html file
  */
 template <typename Scalar>
-void Browse_Matrices(const string folder, bool statFileExists, std::string& statFile, int maxiters, double tol)
+void Browse_Matrices(const std::string folder, bool statFileExists, std::string& statFile, int maxiters, double tol)
 {
-  MaximumIters = maxiters; // Maximum number of iterations, global variable 
+  MaximumIters = maxiters; // Maximum number of iterations, global variable
   RelErr = tol;  //Relative residual error  as stopping criterion for iterative solvers
   MatrixMarketIterator<Scalar> it(folder);
   for ( ; it; ++it)
   {
-    //print the infos for this linear system 
+    //print the infos for this linear system
     if(statFileExists)
     {
       std::ofstream statbuf(statFile.c_str(), std::ios::app);
       statbuf << "<LINEARSYSTEM> \n";
       statbuf << "   <MATRIX> \n";
-      statbuf << "     <NAME> " << it.matname() << " </NAME>\n"; 
-      statbuf << "     <SIZE> " << it.matrix().rows() << " </SIZE>\n"; 
+      statbuf << "     <NAME> " << it.matname() << " </NAME>\n";
+      statbuf << "     <SIZE> " << it.matrix().rows() << " </SIZE>\n";
       statbuf << "     <ENTRIES> " << it.matrix().nonZeros() << "</ENTRIES>\n";
       if (it.sym()!=NonSymmetric)
       {
-        statbuf << "     <SYMMETRY> Symmetric </SYMMETRY>\n" ; 
-        if (it.sym() == SPD) 
-          statbuf << "     <POSDEF> YES </POSDEF>\n"; 
-        else 
-          statbuf << "     <POSDEF> NO </POSDEF>\n"; 
-          
+        statbuf << "     <SYMMETRY> Symmetric </SYMMETRY>\n" ;
+        if (it.sym() == SPD)
+          statbuf << "     <POSDEF> YES </POSDEF>\n";
+        else
+          statbuf << "     <POSDEF> NO </POSDEF>\n";
+
       }
       else
       {
-        statbuf << "     <SYMMETRY> NonSymmetric </SYMMETRY>\n" ; 
-        statbuf << "     <POSDEF> NO </POSDEF>\n"; 
+        statbuf << "     <SYMMETRY> NonSymmetric </SYMMETRY>\n" ;
+        statbuf << "     <POSDEF> NO </POSDEF>\n";
       }
       statbuf << "   </MATRIX> \n";
       statbuf.close();
     }
-    
+
     cout<< "\n\n===================================================== \n";
     cout<< " ======  SOLVING WITH MATRIX " << it.matname() << " ====\n";
     cout<< " =================================================== \n\n";
     Matrix<Scalar, Dynamic, 1> refX;
     if(it.hasrefX()) refX = it.refX();
-    // Call all suitable solvers for this linear system 
+    // Call all suitable solvers for this linear system
     SelectSolvers<Scalar>(it.matrix(), it.sym(), it.rhs(), refX, statFile);
-    
+
     if(statFileExists)
     {
       std::ofstream statbuf(statFile.c_str(), std::ios::app);
       statbuf << "  <BEST_SOLVER ID='"<< best_time_id
-              << "'></BEST_SOLVER>\n"; 
-      statbuf << " </LINEARSYSTEM> \n"; 
+              << "'></BEST_SOLVER>\n";
+      statbuf << " </LINEARSYSTEM> \n";
       statbuf.close();
     }
-  } 
-} 
+  }
+}
 
-bool get_options(int argc, char **args, string option, string* value=0)
+bool get_options(int argc, char **args, std::string option, std::string* value=0)
 {
-  int idx = 1, found=false; 
+  int idx = 1, found=false;
   while (idx<argc && !found){
     if (option.compare(args[idx]) == 0){
-      found = true; 
+      found = true;
       if(value) *value = args[idx+1];
     }
     idx+=2;
   }
-  return found; 
+  return found;
 }
diff --git a/gtsam/geometry/SOn-inl.h b/gtsam/geometry/SOn-inl.h
index 0d7f3e108..e1cbe6381 100644
--- a/gtsam/geometry/SOn-inl.h
+++ b/gtsam/geometry/SOn-inl.h
@@ -22,8 +22,6 @@
 
 #include <iostream>
 
-using namespace std;
-
 namespace gtsam {
 
 // Implementation for N>5 just uses dynamic version
@@ -115,7 +113,7 @@ typename SO<N>::VectorN2 SO<N>::vec(
 
 template <int N>
 void SO<N>::print(const std::string& s) const {
-    cout << s << matrix_ << endl;
+    std::cout << s << matrix_ << std::endl;
 }
 
 }  // namespace gtsam
diff --git a/gtsam/navigation/tests/imuFactorTesting.h b/gtsam/navigation/tests/imuFactorTesting.h
index 5aa83e87e..e02fbfa49 100644
--- a/gtsam/navigation/tests/imuFactorTesting.h
+++ b/gtsam/navigation/tests/imuFactorTesting.h
@@ -20,7 +20,6 @@
 #include <gtsam/navigation/ImuBias.h>
 #include <gtsam/inference/Symbol.h>
 
-using namespace std;
 using namespace gtsam;
 
 // Convenience for named keys
@@ -54,13 +53,13 @@ struct ImuMeasurement {
 };
 
 template <typename PIM>
-void integrateMeasurements(const vector<ImuMeasurement>& measurements,
+void integrateMeasurements(const std::vector<ImuMeasurement>& measurements,
                            PIM* pim) {
   for (const auto& m : measurements)
     pim->integrateMeasurement(m.acc, m.gyro, m.dt);
 }
 
-struct SomeMeasurements : vector<ImuMeasurement> {
+struct SomeMeasurements : std::vector<ImuMeasurement> {
   SomeMeasurements() {
     reserve(102);
     const double dt = 0.01, pi100 = M_PI / 100;
diff --git a/gtsam/slam/KarcherMeanFactor-inl.h b/gtsam/slam/KarcherMeanFactor-inl.h
index f10cc7e42..c0ca6855b 100644
--- a/gtsam/slam/KarcherMeanFactor-inl.h
+++ b/gtsam/slam/KarcherMeanFactor-inl.h
@@ -21,12 +21,10 @@
 #include <gtsam/nonlinear/NonlinearFactorGraph.h>
 #include <gtsam/slam/KarcherMeanFactor.h>
 
-using namespace std;
-
 namespace gtsam {
 
 template <class T, class ALLOC>
-T FindKarcherMeanImpl(const vector<T, ALLOC>& rotations) {
+T FindKarcherMeanImpl(const std::vector<T, ALLOC>& rotations) {
   // Cost function C(R) = \sum PriorFactor(R_i)::error(R)
   // No closed form solution.
   NonlinearFactorGraph graph;
diff --git a/gtsam/slam/tests/smartFactorScenarios.h b/gtsam/slam/tests/smartFactorScenarios.h
index 4abc59305..b2c1c62f5 100644
--- a/gtsam/slam/tests/smartFactorScenarios.h
+++ b/gtsam/slam/tests/smartFactorScenarios.h
@@ -23,7 +23,6 @@
 #include <gtsam/geometry/Cal3_S2.h>
 #include <gtsam/geometry/Cal3Bundler.h>
 
-using namespace std;
 using namespace gtsam;
 
 // three landmarks ~5 meters infront of camera
diff --git a/gtsam_unstable/linear/LP.h b/gtsam_unstable/linear/LP.h
index fc00c2240..ac15cf0d5 100644
--- a/gtsam_unstable/linear/LP.h
+++ b/gtsam_unstable/linear/LP.h
@@ -26,8 +26,6 @@
 
 namespace gtsam {
 
-using namespace std;
-
 /// Mapping between variable's key and its corresponding dimensionality
 using KeyDimMap = std::map<Key, size_t>;
 /*
@@ -64,7 +62,7 @@ public:
   }
 
   /// print
-  void print(const string& s = "") const {
+  void print(const std::string& s = "") const {
     std::cout << s << std::endl;
     cost.print("Linear cost: ");
     equalities.print("Linear equality factors: ");
diff --git a/gtsam_unstable/linear/LPInitSolver.cpp b/gtsam_unstable/linear/LPInitSolver.cpp
index 8c3df3132..ac9dc9139 100644
--- a/gtsam_unstable/linear/LPInitSolver.cpp
+++ b/gtsam_unstable/linear/LPInitSolver.cpp
@@ -21,6 +21,8 @@
 #include <gtsam_unstable/linear/LPSolver.h>
 #include <gtsam_unstable/linear/InfeasibleOrUnboundedProblem.h>
 
+using namespace std;
+
 namespace gtsam {
 
 /******************************************************************************/
diff --git a/timing/timeSFMBAL.h b/timing/timeSFMBAL.h
index 548c4de70..123a243eb 100644
--- a/timing/timeSFMBAL.h
+++ b/timing/timeSFMBAL.h
@@ -28,7 +28,6 @@
 #include <string>
 #include <vector>
 
-using namespace std;
 using namespace gtsam;
 using symbol_shorthand::C;
 using symbol_shorthand::K;
@@ -41,10 +40,10 @@ static SharedNoiseModel gNoiseModel = noiseModel::Unit::Create(2);
 SfmData preamble(int argc, char* argv[]) {
   // primitive argument parsing:
   if (argc > 2) {
-    if (strcmp(argv[1], "--colamd"))
+    if (std::strcmp(argv[1], "--colamd"))
       gUseSchur = false;
     else
-      throw runtime_error("Usage: timeSFMBALxxx [--colamd] [BALfile]");
+      throw std::runtime_error("Usage: timeSFMBALxxx [--colamd] [BALfile]");
   }
 
   // Load BAL file
@@ -55,7 +54,7 @@ SfmData preamble(int argc, char* argv[]) {
   else
     filename = findExampleDataFile("dubrovnik-16-22106-pre");
   bool success = readBAL(filename, db);
-  if (!success) throw runtime_error("Could not access file!");
+  if (!success) throw std::runtime_error("Could not access file!");
   return db;
 }
 
diff --git a/wrap/matlab.h b/wrap/matlab.h
index 1af00bd00..076e8c8b2 100644
--- a/wrap/matlab.h
+++ b/wrap/matlab.h
@@ -42,7 +42,6 @@ extern "C" {
 #include <set>
 #include <streambuf>
 
-using namespace std;
 using namespace boost; // not usual, but for conciseness of generated code
 
 // start GTSAM Specifics /////////////////////////////////////////////////
@@ -110,7 +109,7 @@ protected:
 //*****************************************************************************
 
 void checkArguments(const string& name, int nargout, int nargin, int expected) {
-  stringstream err;
+  std::stringstream err;
   err << name << " expects " << expected << " arguments, not " << nargin;
   if (nargin!=expected)
     error(err.str().c_str());
@@ -231,10 +230,10 @@ T unwrap(const mxArray* array) {
 // expects a character array
 // Warning: relies on mxChar==char
 template<>
-string unwrap<string>(const mxArray* array) {
+string unwrap<std::string>(const mxArray* array) {
   char *data = mxArrayToString(array);
   if (data==NULL) error("unwrap<string>: not a character array");
-  string str(data);
+  std::string str(data);
   mxFree(data);
   return str;
 }
